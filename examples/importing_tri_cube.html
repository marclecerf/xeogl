<!DOCTYPE html>
<html lang="en">
  <head>
    <title>xeogl Example</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    <link href="css/styles.css" rel="stylesheet"/>

    <script src="../build/xeogl.js"></script>
  </head>
  <body>
    <script>

      "use strict";

      fetch('cube.tri')
      .then((response) => {
        return response.arrayBuffer();
      })
      .then((buffer) => {
        let model = readMultiZoneTriModel(buffer);
        model.normals = computeNormals(model);
        //let model = exampleModel();
        console.log(model);
        var mesh = new xeogl.Mesh({
            geometry: new xeogl.Geometry({
                primitive: "triangles",
                positions: model.positions,
                normals: model.normals,
                indices: model.indices
            }),
            material: new xeogl.PhongMaterial({
                diffuse: [0.6, 0.6, 1.0]
            })
        });

        var scene = mesh.scene;
        var camera = scene.camera;

        scene.on("tick", function () {
            camera.orbitYaw(0.2);
            camera.orbitPitch(0.1);
        });

        new xeogl.CameraControl();
      });

      function exampleModel() {
        return {
          // The vertices - eight for our cube, each
          // one spanning three array elements for X,Y and Z
          positions: [

              // v0-v1-v2-v3 front
              2, 2, 2,
              -2, 2, 2,
              -2, -2, 2,
              2, -2, 2,

              // v0-v3-v4-v1 right
              2, 2, 2,
              2, -2, 2,
              2, -2, -2,
              2, 2, -2,

              // v0-v1-v6-v1 top
              2, 2, 2,
              2, 2, -2,
              -2, 2, -2,
              -2, 2, 2,

              // v1-v6-v7-v2 left
              -2, 2, 2,
              -2, 2, -2,
              -2, -2, -2,
              -2, -2, 2,

              // v7-v4-v3-v2 bottom
              -2, -2, -2,
              2, -2, -2,
              2, -2, 2,
              -2, -2, 2,

              // v4-v7-v6-v1 back
              2, -2, -2,
              -2, -2, -2,
              -2, 2, -2,
              2, 2, -2
          ],

          // Normal vectors, one for each vertex
          normals: [

              // v0-v1-v2-v3 front
              0, 0, 1,
              0, 0, 1,
              0, 0, 1,
              0, 0, 1,

              // v0-v3-v4-v5 right
              1, 0, 0,
              1, 0, 0,
              1, 0, 0,
              1, 0, 0,

              // v0-v5-v6-v1 top
              0, 1, 0,
              0, 1, 0,
              0, 1, 0,
              0, 1, 0,

              // v1-v6-v7-v2 left
              -1, 0, 0,
              -1, 0, 0,
              -1, 0, 0,
              -1, 0, 0,

              // v7-v4-v3-v2 bottom
              0, -1, 0,
              0, -1, 0,
              0, -1, 0,
              0, -1, 0,

              // v4-v7-v6-v5 back
              0, 0, -1,
              0, 0, -1,
              0, 0, -1,
              0, 0, -1
          ],

          // Indices - these organise the
          // positions and uv texture coordinates
          // into geometric primitives in accordance
          // with the "primitive" parameter,
          // in this case a set of three indices
          // for each triangle.
          //
          // Note that each triangle is specified
          // in counter-clockwise winding order.
          //
          // You can specify them in clockwise
          // order if you configure the Material
          // frontface property as "cw", instead
          // of the default "ccw".
          indices: [
              0, 1, 2,
              0, 2, 3,
              // front
              4, 5, 6,
              4, 6, 7,
              // right
              8, 9, 10,
              8, 10, 11,
              // top
              12, 13, 14,
              12, 14, 15,
              // left
              16, 17, 18,
              16, 18, 19,
              // bottom
              20, 21, 22,
              20, 22, 23
          ]
        };
      }

      function readMultiZoneTriModel(buffer) {
        let stream = {
          buffer: buffer,
          index: 0,
          readInt32: function () {
            let value = new DataView(buffer).getInt32(this.index, true);
            this.index = this.index + 4;
            return value;
          },
          readFloat32: function() {
            let value = new DataView(buffer).getFloat32(this.index, true);
            this.index = this.index + 4;
            return value;
          }
        };
        let numberZones = stream.readInt32();
        let zones = [];
        for (let ii = 0; ii < numberZones; ii++) {
          let numberPoints = stream.readInt32();
          let numberTriangles = stream.readInt32();
          let numberTetrahedra = stream.readInt32();
          zones.push({numberPoints: numberPoints,
                      numberTriangles: numberTriangles,
                      numberTetrahedra: numberTetrahedra});
        }
        let scale = function (v) { return v; };

        let vertices = [];
        let colors = [];
        let indices = [];

        for (let jj = 0; jj < numberZones; jj++) {
          let numberPoints = zones[jj].numberPoints;
          let numberTriangles = zones[jj].numberTriangles;
          let numberTetrahedra = zones[jj].numberTetrahedra;
          let x = [];
          for (let ii = 0; ii < numberPoints; ii++) {
            x.push(scale(stream.readFloat32()));
          }
          let y = [];
          for (let ii = 0; ii < numberPoints; ii++) {
            y.push(scale(stream.readFloat32()));
          }
          let z = [];
          for (let ii = 0; ii < numberPoints; ii++) {
            z.push(scale(stream.readFloat32()));
          }

          for (let ii = 0; ii < numberPoints; ii++) {
            vertices.push(x[ii]);
            vertices.push(y[ii]);
            vertices.push(z[ii]);
          }

          for (let ii = 0; ii < numberTriangles; ii++) {
            for (let tt = 0; tt < 3; tt++) {
              let idx = stream.readInt32();
              indices.push(idx);
            }
          }
        }

        return {
          positions: vertices,
          indices: indices,
        };
      }

      // Compute normal for each vertex
      function computeNormals(model) {
        // Normal at each vertex is an equal-weighted average
        // of normal vector at each face containing the
        // vertex.
        let normals = new Array(model.positions.length);
        for (let ii = 0; ii < normals.length; ii++) {
          normals[ii] = 0;
        }
        for (let ii = 0; ii < model.indices.length; ii += 3) {
          let v0 = model.indices[ii + 0];
          let v1 = model.indices[ii + 1];
          let v2 = model.indices[ii + 2];
          let v0x = model.positions[v0 * 3 + 0];
          let v0y = model.positions[v0 * 3 + 1];
          let v0z = model.positions[v0 * 3 + 2];
          let v1x = model.positions[v1 * 3 + 0];
          let v1y = model.positions[v1 * 3 + 1];
          let v1z = model.positions[v1 * 3 + 2];
          let v2x = model.positions[v2 * 3 + 0];
          let v2y = model.positions[v2 * 3 + 1];
          let v2z = model.positions[v2 * 3 + 2];
          let r01x = v1x - v0x;
          let r01y = v1y - v0y;
          let r01z = v1z - v0z;
          let r02x = v2x - v0x;
          let r02y = v2y - v0y;
          let r02z = v2z - v0z;
          // r01 x r02
          let nx = r01y * r02z - r01z * r02y;
          let ny = r01z * r02x - r01x * r02z;
          let nz = r01x * r02y - r01y * r02x;
          let nmag = Math.sqrt(nx * nx + ny * ny + nz * nz);
          nx = nx / nmag;
          ny = ny / nmag;
          nz = nz / nmag;
          normals[v0 * 3 + 0] += nx;
          normals[v0 * 3 + 1] += ny;
          normals[v0 * 3 + 2] += nz;
          normals[v1 * 3 + 0] += nx;
          normals[v1 * 3 + 1] += ny;
          normals[v1 * 3 + 2] += nz;
          normals[v2 * 3 + 0] += nx;
          normals[v2 * 3 + 1] += ny;
          normals[v2 * 3 + 2] += nz;
        }
        for (let ii = 0; ii < normals.length; ii += 3) {
          let nx = normals[ii + 0];
          let ny = normals[ii + 1];
          let nz = normals[ii + 2];
          let nmag = Math.sqrt(nx * nx + ny * ny + nz * nz);
          normals[ii + 0] = normals[ii + 0] / nmag;
          normals[ii + 1] = normals[ii + 1] / nmag;
          normals[ii + 2] = normals[ii + 2] / nmag;
        }
        return normals;
      }
    </script>
  </body>
</html>
